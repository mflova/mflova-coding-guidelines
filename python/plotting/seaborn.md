# Seaborn

Recommended sources: Kimberly Fessel YT channel.

## Main philosophy

Within this framework we have to understand that there are two main kind of plots:

- `Axes-level`: Create and edit and `Axes` object. Therefore everything will be
  self-contained within this object. Some of the consequences are 1) legends will be
  inside the plot and 2) you will not be able to directly create subplots with these.
  However, you can always create them by using the keyword argument `ax` being `ax` one of
  the axes generated by using the `matplotlib` API.
- `Figure-level`: Create and edit the plot at the figure level (concept of `matplotlib`).
  They have more control. As a consequence, legends will be placed outside and you will eb
  able to create easy subplots with them. These functions are created as
  wrappers/collections around the `Axes-level` ones. For example, `sns.relplot` will end
  up calling `sns.scatterplot` or `sns.lineplot` if we use `kind=scatter` or `kind=line`
  respectively. These will always have the `kind` argument to easily switch between
  different representations. There are three of these wrappers:
    - `sns.relplot`: Handle statistical relationships
      - By default, these will tend to plot uncertainty around the series. Avoid is by
        doing `error_bar=None`
    - `sns.catplot`: To handle the representation of categorical data.
    - `sns.displot`: Representation of distributions (including the accumulative ones)
  However, not all plots will be contained within these 3 wrappers. Be aware of it

You can easily check the type of each `sns`-based plot just by looking at its return type.
`Axes` means that the plot is of type `Axes-level`. Else, `Figure-level`.

[Here](https://seaborn.pydata.org/tutorial/function_overview.html#figure-level-vs-axes-level-functions)
you can see more information about the API.

## Figure-level

### Cluster map

Among a dataset with multiple variables, this one will represent which ones are the most
related ones. For example, imagine I have the `penguins` dataset where I have, for each
penguin, the `fin_size_mm`, `height`...

This type of plot will show me not only which variables are correlated (for example, let's
say `fin_size_mm` and `height`) but also individual species whose set of parameters are
related. Clustermap will generate a hierarchy that relates all species and parameters.

If variables have different scales, `standard_scale=True` can be helpful.

### Relplot

It comes from relational plots. Meant to handle statistical relationships. With kind,
these can be:

- scatterplot() (with kind="scatter"; the default)
- lineplot() (with kind="line")

### Displot

Handle distributions. Both univariate or bivariate. Based on the keyword argument `kind`,
these can be:

- histplot() (with kind="hist"; the default)
- kdeplot() (with kind="kde"): Kernel density estimation. For each observation, a kernel
  (gaussian by default) will be added to the plot. This will give us a continious
  approximation of our distribution. It can be useful to compare multiple distributions as
  these ones can be represented with a line instead of with histogram bars. It can be
  acumulative as well. However, this type of plot can be misleading speciallly at both
  ends, as the maximum and minimum values are not properly represented due to the kernel.
  It can be used to generate heatmaps (see corresponding section).
- ecdfplot() (with kind="ecdf"; univariate-only): Empirical cumulative distribution. It
  represents the cumulative count of the observations. One important argument is
  `weight`. We can use this one to weight the count (thus not making it based on the
  observation count but, as an example, the total money earned)

### Catplot

Handle the representation of categorical data. Among others, these can be:

- Categorical scatterplots:

  - stripplot() (with kind="strip"; the default): Similar to the swarmplot but this one
    presents overlapping. Therefore, if `alpha` parameter is used, density can be
    highlighted by the intensity of the color.
  - swarmplot() (with kind="swarm"): Plot the categorical observations in a "scattered"
    way. Points are never overlapping therefore the width of the accumulated points will
    highlight the density of the data.

- Categorical distribution plots:

  - boxplot() (with kind="box")
  - violinplot() (with kind="violin")
  - boxenplot() (with kind="boxen")

- Categorical estimate plots: In these type of plots, the data is "processed" or
  aggregated in a specific way:

  - pointplot() (with kind="point")
  - barplot() (with kind="bar"): It will aggregate the data based on mean by default.
    Then, it will compute the confidence interval of it
  - countplot() (with kind="count"): Performs the count. Barplot performs aggregation on
    the data.

### FacetGrid

This one, combined with `map` or `map_dataframe` allows you to define a grid where each
column or row can be represented by a different variable. After it, `map_dataframe` will
only need to indicate the type of plot you need `sns.lineplot`, `sns.scatterplot`... And
corresponding kwargs. It is also possible to call `map_dataframe` multiple times. I can
also pass a custom function that makes use of different functions of `sns` to repesent
data as well. Here I can also pass `hue` argument. If I wanted to modify the way title are
shown, I can do it with:

```py
# Being g and object of type FacetGrid
g.set_titles(col_template='{col_name} Island', row_template='{row_name}');
```

I can also access many other attributes such as:

```py
g.ax.lines[0].get_color()
```

### Linear model plot (lmplot)

`sns.lmplot`: From linear model plot. Perform regression-based plots. Its equivalent
`Axes-level` plot is `sns.regplot`

### Pairplot

`sns.pairplot`: For pair-wise relationship. It will generate a grid that plots the
marginal distribution on the diagonal and relationship plots between paired variables on
all the other ones. Example: `sns.pairplot(iris, hue="species")`. Created under the hood
with `sns.PairGrid`.

This plot is more flexible than it seems. Another use is by indicating `vars` and the list
of all columnts. If I want even more control, I can provide `x_vars` and `y_vars` in order
to fix the variables I want to represent I also have arguments such as `diag_kws` to
modify the behaviour of specific subplots like, in this case, for the diagonal ones.

### Jointplot

`sns.jointplot` For bivariate distributions. Plots a relationship-based plot on the center
and, on top of that, on the side, the marginal distribution of each isolated variable.
This one has specific keywords sucgh as `joint_kws` or `marginal_kws` to send specific
parameters to these isolated plots. If you are looking for a more specific representation,
be aware that these are created via `sns.JointGrid`. Take a look at it.

## Axes-level

In this section we are not including the ones that are groupped within the `Figure-level`
wrappers `relplot`, `catplot` and `displot`.

The most interesting type of plots:

### Regplot

`sns.regplot`: Perform regression-based plots. Its equivalent `Figure-level` plot is
`sns.lmplot`

### Heatmap

`sns.heatmap` when the dataframe represents a table, heatmap will generate its
corresponding heatmap. Recomended to use `square=True` to force all rectangles are forced
to be squared. Heatmap will typically require that the information is groupped within a
finite table. This means that if you are dealing with continuous signals, you will have to
use `pd.cut` in order to create bins. As an alternative, you can also use any `kde` based
plot to represent bivariate distributions (these are either `sns.displot(kind="kde")` or
`sns.kdeplot` with `x=`, `y=` and `fill=True` arguments given). Then, you can increase
`levels` keyword argument and optionally `cut` to cut the representation beyond both ends
of the distribution. For this one you will not need to group the data in bins. Just the
pivot table.

### Residplot 

`sns.residplot`: This one will internally perform a linear regression and then plot the
residuals. It can be helpful to know in which section of the data the regression struggles
to fit.

## Interesting features

### Keywords

The `seaborn` interface is quite uniform. Be aware that many keywords will be
automatically redirected to the `matplotlib` equivalent function. As an example, these
will be arguments such as `lw` for the line width. Along many implementation you will find
some specific keywords that are in most of the plots. These can be:

- `color`: This one can use a constant color for all of our plots. If this one is used in
  combination with `hue`, a gradient of this same color will be obtained.
- `palette`: This one will use a specific palette in our plot. This one defines multiple
  colors.
- `hue`: If the plot allows this argument, you can write the name of a pandas column and
  seaborn will automatically encode that information into the color of the plot.
- `style`: If the plot allows this argument, you can write the name of a pandas column and
  seaborn will automatically encode that information into the marker style of the plot.
- `size`: If the plot allows this argument, you can write the name of a pandas column and
  seaborn will automatically encode that information into the marker size of the plot.
- `row`/`col`: If the plot allows subplots (these are typically the figure-level
  implementations), you can indicate the column name on `row`/`col` to split the
  information of that column into multiple plots.

### Styling

Usually, all palettes will have a `_r` version. This means that it is is the reversed
version. In otder to create palette, I can do:

- `sns.dark_palette("color")`: It will create a paltte from dartk to the color given.
- `sns.light_palette("color")`: It will create a paltte from white to the color given.
- `sns.blend_palette(list_of_colors)`: It will create a "gradient" between all colors
  given.
  
All palette usually accept a integer after the first argument that indicates how many
colors the gradient will have.

Highlight a specific series: For this, I can create a dictionary with keys the name of all
non-highlighted series represented and the value `gray` and the one I want to highlight
with `red`. Then I only need to pass it to the kwarg `palette` from any plot.

I can also use `sns.choose_colorbrewer_palette()` function to create an interactive widget
where I can create the desired palette. It must be used in jupyter-based notebooks.

### Subplots

In order to create subplots, there are few different ways. The recommended ones, in order,
are:

- `Figure-level` plots: These are `sns.relplot`, `sns.catplot` and `sns.displot`. These
  allow the argument `row`/`col`. There you can indicate the column name of a pandas
  dataframe to split the information based on this column. This is the esiest way but all
  plots will be uniform. If you want to customize a bit more, you will not be able to do
  so.
- `sns.Facetgrid(row=..., col=...).map_dataframe(func, **kwargs)`: Here you will create a
  grid in a similar way as in the previous point. However, this time you can provide a
  function `func` that can be a standard one like `sns.regplot` or any other function
  created by the user. This one allows way more customization. However, this method is
  still limitted in the sense that the same function will be applied to all of them.
- `fix, axes = plt.subplots(2, 2)`: Later you can pass the `ax` object to any `Axes-level`
  based figure (such as `boxplot`)