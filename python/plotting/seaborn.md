# Seaborn

Some plots or explanations might still be missing:

- Clustermap
- Jointplot
- Pairplot

## Main philosophy

Within this framework we have to understand that there are two main kind of plots:

- `Axes-level`: Create and edit and `Axes` object. Therefore everything will be
  self-contained within this object. Some of the consequences are 1) legends will be
  inside the plot and 2) you will not be able to directly create subplots with these.
  However, you can always create them by using the keyword argument `ax` being `ax` one of
  the axes generated by using the `matplotlib` API.
- `Figure-level`: Create and edit the plot at the figure level (concept of `matplotlib`).
  They have more control. As a consequence, legends will be placed outside and you will eb
  able to create easy subplots with them. These functions are created as
  wrappers/collections around the `Axes-level` ones. For example, `sns.relplot` will end
  up calling `sns.scatterplot` or `sns.lineplot` if we use `kind=scatter` or `kind=line`
  respectively. These will always have the `kind` argument to easily switch between
  different representations. There are three of these wrappers:
    - `sns.relplot`: Handle statistical relationships
      - By default, these will tend to plot uncertainty around the series. Avoid is by
        doing `error_bar=None`
    - `sns.catplot`: To handle the representation of categorical data.
    - `sns.displot`: Representation of distributions (including the accumulative ones)
  However, not all plots will be contained within these 3 wrappers. Be aware of it

You can easily check the type of each `sns`-based plot just by looking at its return type.
`Axes` means that the plot is of type `Axes-level`. Else, `Figure-level`.

[Here](https://seaborn.pydata.org/tutorial/function_overview.html#figure-level-vs-axes-level-functions)
you can see more information about the API.

## Figure-level

- `sns.FacetGrid`: This one, combined with `map` or `map_dataframe` allows you to define a
  grid where each column or row can be represented by a different variable. After it,
  `map_dataframe` will only need to indicate the type of plot you need `sns.lineplot`,
  `sns.scatterplot`... And corresponding kwargs. I can also pass a custom function that
  makes use of different functions of `sns` to repesent data as well.
- `sns.lmplot`: Perform regression-based plots. Its equivalent `Axes-level` plot is
  `sns.regplot`
- `sns.pairplot`: For distributions. It will generate a grid that shows the correlation
  between variables given. Example: `sns.pairplot(iris, hue="species")`. Created under the
  hood with `sns.PairGrid`.
- `sns.jointplot`: For distributions. Plots the information as a scatter and, on top of
  that, on the side, a histogram that represents each of the two variables. If you are
  looking for a more specific representation, be aware that these are created via
  `sns.JointGrid`. Take a look at it.

## Axes-level

In this section we are not including the ones that are groupped within the `Figure-level`
wrappers `relplot`, `catplot` and `displot`.

The most interesting type of plots:

- `sns.regplot`: Perform regression-based plots. Its equivalent `Figure-level` plot is
  `sns.lmplot`
- `sns.heatmap` when the dataframe represents a table, heatmap will generate its
  corresponding heatmap
- `sns.residplot`: This one will internally perform a linear regression and then plot the
  residuals. It can be helpful to know in which section of the data the regression
  struggles to fit.

## Interesting features

### Keywords

The `seaborn` interface is quite uniform. Along many implementation you will find some
specific keywords that are in most of the plots. These can be:

- `hue`: If the plot allows this argument, you can write the name of a pandas column and
  seaborn will automatically encode that information into the color of the plot.
- `style`: If the plot allows this argument, you can write the name of a pandas column and
  seaborn will automatically encode that information into the marker style of the plot.
- `size`: If the plot allows this argument, you can write the name of a pandas column and
  seaborn will automatically encode that information into the marker size of the plot.
- `row`/`col`: If the plot allows subplots (these are typically the figure-level
  implementations), you can indicate the column name on `row`/`col` to split the
  information of that column into multiple plots.

### Subplots

In order to create subplots, there are few different ways. The recommended ones, in order,
are:

- `Figure-level` plots: These are `sns.relplot`, `sns.catplot` and `sns.displot`. These
  allow the argument `row`/`col`. There you can indicate the column name of a pandas
  dataframe to split the information based on this column. This is the esiest way but all
  plots will be uniform. If you want to customize a bit more, you will not be able to do
  so.
- `sns.Facetgrid(row=..., col=...).map_dataframe(func, **kwargs)`: Here you will create a
  grid in a similar way as in the previous point. However, this time you can provide a
  function `func` that can be a standard one like `sns.regplot` or any other function
  created by the user. This one allows way more customization. However, this method is
  still limitted in the sense that the same function will be applied to all of them.
- `fix, axes = plt.subplots(2, 2)`: Later you can pass the `ax` object to any `Axes-level`
  based figure (such as `boxplot`)