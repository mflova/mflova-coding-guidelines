# Typing

## Stubs

Stubs are .fyi files that contain information relative to the input-output
types of all the functions belonging to a module. These can be generated
with mypy or stubgen. It can be generated by:

- Path: It will recusively search the path and generate the stub files.
- Reference to specific module: For example, the module B, located at A.B.
  However, it will also be necessary to build the previous one so that the
  type checkers can find the reference to B. In this case the previous one is A.
- Package: If I have A.B.C and I build he stubs for the package A, all
  the contained modules will be processed as well.

## Conflict between types at runtime vs at type checking

When running at runtime, types are checked in real time through the module.
However, type checkers use the information and types from the generated stubs.
Due to this, some classes might be defined as generic (pd.Series) but the type
checkers might require a type (pd.Series[float]). This last one will make the
Python script crash at runtime. How to solve this issue?

- From Python 3.7 to 3.10, use from __future__ import annotations
- Installed Python 3.11
- Use of typing.TYPE\_CHECKING: By importing it, you can do an if-else statement
  based on this variable. TYPE\_CHECKING will be 1 when the type checkers run,
  and 0 during runtime. Knowing this, I can define two different types that will
  deal with this issue.
- Use of string literal types: This ones are not checked during runtime.
  It is literally writting the type annotation as a string. See [example](https://stackoverflow.com/questions/56218842/how-do-i-use-string-literal-type-annotations-for-multiple-possible-argument-type).

Links: [Mypy type checkers vs runtime](https://mypy.readthedocs.io/en/stable/runtime_troubles.html)

## Better definition of relationship between input-output types

There will be situations where, depending on the input type, the output type
will be completely different. For example, a function that creates a list
duplicating the input element (either str or float), it will be written like this:

```
def duplicate(value: Union[float, str]) - Union[List[float], List[str]]:
```

However, to improve the type annotation, the @overload keyword can be used to
define a different behaviour of the function (or only different input-output types)
depending on the input type:

```
from typing import overload

# Note: Overload methods MUST be above the non-overload method.
# These ones are ignored at runtime. Checked by the type checker.
@overload
def duplicate(value: float) -> List[float]: ...

@overload
def duplicate(value: str) -> List[str]: ...

# Contains runtime logic. It might or might not contain type hints
# However, mypy --strict will give an error if no type hints are defined
def duplicate(value):
    return [value, value]

```

See [Overlading and type hints in mypy](https://mypy.readthedocs.io/en/stable/more_types.html)
Three dots indicate that the content of this function is not modified.
However, what happens when I cannot modify the module?

See [Own question](https://stackoverflow.com/questions/70419778/incompatible-union-assignment-python)

Links: [Stack overflow question](https://stackoverflow.com/questions/48127642/incompatible-types-in-assignment-on-union)
[Overload decorator](https://stackoverflow.com/questions/8654666/decorator-for-overloading-in-python)


